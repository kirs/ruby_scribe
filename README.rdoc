= Ruby Scribe

== Introduction

Seattle RB's ruby_parser is a great tool for parsing ruby code into syntax trees.  Ruby Scribe is the reverse of this - a tool for taking an S-expression in Ruby and emitting clean code.  It does this by providing a series of rules that intelligently formats code much as a real developer would.

== Example

Imagine this crappily-formatted Ruby code:
  
  module RubyScribe


    # My Comment
    class Sample  < Base; 
         def method; do_something_here; end

     if(new_record?) then
         puts "Yes"
      else
             puts 'No'
        end
    end
   end

Here is the syntax tree for the above:
  
  s(:module,
   :RubyScribe,
   s(:scope,
    s(:class,
     :Sample,
     s(:const, :Base),
     s(:scope,
      s(:block,
       s(:defn,
        :method,
        s(:args),
        s(:scope, s(:block, s(:call, nil, :do_something_here, s(:arglist))))),
       s(:if,
        s(:call, nil, :new_record?, s(:arglist)),
        s(:call, nil, :puts, s(:arglist, s(:str, "Yes"))),
        s(:call, nil, :puts, s(:arglist, s(:str, "No")))))))))

Parse that with RubyParser, then emit it with RubyScribe:
  
  sexp = RubyParser.new.parse(File.read("bad_code.rb"))
  RubyScribe::Emitter.new.emit(sexp)

And out pops this:
  
  module RubyScribe
    # My Comment
    class Sample < Base
      def method
        do_something_here
      end

      if new_record?
        puts "Yes"
      else
        puts "No"
      end
    end
  end


== Applications

The combination of these two tools allows some other interesting tools to be written.  One of example tool (and indeed the entire reason I started this project) is my rspecify tool, which can take a test directory with code written using Test::Unit and, via a Ruby Scribe Preprocessor, convert it into RSpec, automating 99% of what a human developer would normally have to do.

Future projects using these two gems could be:
* Automated refactoring tools
* Tools that take a project and try to apply a set of "coding standards"
* Tools that produce metrics on how much your code differs from the project's "coding standards" implementation.

== Usage

The entire project simply takes an incoming Sexp object (from the ruby_parser project) and emits a single string.  To do this just use an Emitter:
  
  RubyScribe::Emitter.new.emit(sexp)  # => "module Something..."

== Emitter Implementation

The +Emitter+ class is nothing but a bunch of recursion.  The main emit method is a big case block to offload handling of individual types to separate methods which handle and compose a big string, all through recursion.  

To extend or implement your own Emitter, just subclass +RubyScribe::Emitter+ and override the necessary methods.

== Preprocess Implementation

This feature is not developed yet, but is intended on presenting a standard recursion-based class for implementing transformations of S-expressions.

== Known Issues

* Since there are still some holes in the implementation, any s-expression type that is unknown will cause the following to be emitted: "## RubyScribe-UNKNOWN: :type ##".  Once stable any unknown type will instead throw an exception.
* Anything involving order of operations currently much surround the expression in ( ).  Will probably expand later to omit this when order of operations is implied, but this requires a context stack.  There may actually be other issues related to order of operations.  To do this properly requires maintaining context of operations and, starting with the case for parenthesis, remove parentheses when the emitter determines that the order of operations is implied by Ruby syntax rules.  Right now the emitter more or less assumes order of operations is implied and does not use parantheses, except in the cases of || and && in which case it does.
* Some of the more obscure types are not implemented.
* Only comments on methods, class, and module declarations are retained.  This is actually a limitation of ruby_parser as for whatever reason 
in-line comments cannot be parsed correctly.

== Future Features

* Maintain a context stack so emit methods can emit different content dependent on context in the stack
* Configuration options for things such as block style, preference for quote style, etc.
